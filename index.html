<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Deriv Full-Auto Trader — Paper & Real (No Martingale)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;background:#071027;color:#e6eef6;margin:0;padding:18px}
  .wrap{max-width:1100px;margin:0 auto}
  .card{background:rgba(255,255,255,0.03);border-radius:10px;padding:12px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.04)}
  label{font-size:12px;color:#9fb4c8;display:block;margin-bottom:6px}
  input,select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#071827;color:#e6eef6;width:100%}
  .grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}
  .row{display:flex;gap:8px}
  button.primary{background:linear-gradient(90deg,#22d3ee,#3b82f6);border:0;color:#002}
  .pill{padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04)}
  .log{height:300px;overflow:auto;background:#021021;padding:10px;border-radius:8px;font-family:ui-monospace,monospace}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
  .muted{color:#9fb4c8;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <h2>Deriv Full-Auto Trader — Paper & Real (No Martingale)</h2>

  <div class="card">
    <div class="grid">
      <div>
        <label>App ID</label>
        <input id="appId" value="1089" />
      </div>

      <div style="grid-column: span 2 / span 2;">
        <label>API Token (required for REAL)</label>
        <input id="token" placeholder="Paste your Deriv API token here" />
      </div>

      <div>
        <label>Mode</label>
        <select id="mode">
          <option value="paper" selected>PAPER (Sim)</option>
          <option value="real">REAL (Live)</option>
        </select>
      </div>

      <div>
        <label>Symbol</label>
        <select id="symbol">
          <option value="R_100">R_100</option>
          <option value="R_75">R_75</option>
          <option value="R_50">R_50</option>
        </select>
      </div>

      <div>
        <label>Stake (USD)</label>
        <input id="stake" type="number" min="0.35" step="0.01" value="1.00" />
      </div>

      <div>
        <label>Duration (ticks) — max 20</label>
        <input id="duration" type="number" min="1" max="20" step="1" value="5" />
      </div>

      <div>
        <label>Payout % (paper calculations only)</label>
        <input id="payout" type="number" value="90" />
      </div>

      <div>
        <label>Max concurrent contracts</label>
        <input id="maxOpen" type="number" value="1" min="1" max="5" />
      </div>

      <div>
        <label>Cooldown (ms between orders)</label>
        <input id="cooldown" type="number" value="900" />
      </div>

      <div>
        <label>Tick loop (ms) — how often bot evaluates</label>
        <input id="tickms" type="number" value="400" />
      </div>

      <div>
        <label>Stop Loss ($)</label>
        <input id="sl" type="number" value="-200" />
      </div>

      <div>
        <label>Take Profit ($)</label>
        <input id="tp" type="number" value="300" />
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="connect" class="primary" style="width:140px">Connect</button>
      <button id="start" class="primary" disabled style="width:140px">Start Bot</button>
      <button id="stop" disabled style="width:140px">Stop Bot</button>
      <div style="margin-left:8px;align-self:center">
        <span class="pill" id="status">DISCONNECTED</span>
      </div>
    </div>
    <div style="margin-top:8px" class="muted">
      Strategy combo: Trend2 (2 consecutive ticks same direction) + Precision (selective candle-based). No martingale.
    </div>
  </div>

  <div class="card">
    <strong>Live / Stats</strong>
    <div style="display:flex;gap:12px;margin-top:8px;flex-wrap:wrap">
      <div class="pill">Virtual P/L: $<span id="pl">0.00</span></div>
      <div class="pill">Trades: <span id="trades">0</span></div>
      <div class="pill">Open: <span id="openCount">0</span></div>
      <div class="pill">Wins: <span id="wins">0</span></div>
      <div class="pill">Losses: <span id="losses">0</span></div>
      <div class="pill">Win% (paper): <span id="wr">0%</span></div>
    </div>
  </div>

  <div class="card" style="display:grid;grid-template-columns:1fr 420px;gap:12px">
    <div>
      <strong>Open Contracts</strong>
      <table id="openTable"><thead><tr><th>ID</th><th>Type</th><th>Stake</th><th>OpenTick</th><th>ExpiryTick</th><th>Status</th></tr></thead><tbody></tbody></table>
    </div>
    <div>
      <strong>Log</strong>
      <pre id="log" class="log"></pre>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const logEl = $('#log');
  const addLog = (t) => { logEl.textContent += new Date().toLocaleTimeString() + ' | ' + t + '\\n'; logEl.scrollTop = logEl.scrollHeight; };
  const fmt = n => Number(n).toFixed(2);
  const setStatus = (t) => { $('#status').textContent = t; };

  // ---------- State ----------
  const state = {
    ws: null,
    isAuthorized: false,
    ticks: [],         // tick quotes
    candles: [],       // pseudo/live candles
    running: false,
    open: new Map(),   // id -> record {id,type,stake,openTick,expiryTick,status,real,contract_id}
    virtualPL: 0,
    wins: 0, losses: 0, trades: 0,
    lastOrderTs: 0,
    tickTimer: null
  };

  // ---------- WS helpers ----------
  function send(obj){
    try { if (state.ws && state.ws.readyState === 1) state.ws.send(JSON.stringify(obj)); }
    catch(e){ addLog('send err: '+(e.message||e)); }
  }
  function authorize(token){ send({ authorize: token }); }
  function subscribeTicks(symbol){ send({ ticks: symbol, subscribe: 1 }); }
  function subscribeCandles(symbol, granularity=60){ send({ ticks_history: symbol, count: 100, end:'latest', style:'candles', granularity, subscribe: 1 }); }

  // ---------- UI helpers ----------
  function updateBadges(){
    $('#pl').textContent = fmt(state.virtualPL);
    $('#wins').textContent = state.wins;
    $('#losses').textContent = state.losses;
    $('#trades').textContent = state.trades;
    $('#openCount').textContent = Array.from(state.open.values()).filter(o=>o.status==='OPEN').length;
    $('#wr').textContent = state.trades ? (100*state.wins/state.trades).toFixed(1) + '%' : '0%';
  }
  function upsertOpenRow(o){
    const tbody = $('#openTable tbody');
    const existing = document.getElementById('row-'+o.id);
    const row = `<tr id="row-${o.id}"><td>${o.id}</td><td>${o.type}</td><td>$${fmt(o.stake)}</td><td>${o.openTick}</td><td>${o.expiryTick ?? '-'}</td><td>${o.status}</td></tr>`;
    if (existing) existing.outerHTML = row; else tbody.insertAdjacentHTML('afterbegin', row);
  }
  function removeOpenRow(id){ const r=document.getElementById('row-'+id); if (r) r.remove(); }

  // ---------- Strategy signals ----------
  function signalTrend2(){
    const n = state.ticks.length;
    if (n < 3) return null;
    const a = state.ticks[n-3], b = state.ticks[n-2], c = state.ticks[n-1];
    if (b > a && c > b) return 'CALL';
    if (b < a && c < b) return 'PUT';
    return null;
  }

  function signalPrecision(){
    const cs = state.candles;
    if (cs.length < 30) return null;
    // last closed candle
    const last = cs[cs.length-2];
    const prev = cs[cs.length-3];
    if (!last || !prev) return null;
    if (last.close > last.open && last.close > prev.close) return 'CALL';
    if (last.close < last.open && last.close < prev.close) return 'PUT';
    return null;
  }

  // ---------- Trade placement ----------
  const CONTRACT_DURATION_MAX = 20;
  function canPlace(){
    const maxOpen = Number($('#maxOpen').value || 1);
    const openCount = Array.from(state.open.values()).filter(o=>o.status==='OPEN').length;
    if (openCount >= maxOpen) return false;
    const cooldown = Number($('#cooldown').value || 900);
    if (Date.now() - state.lastOrderTs < cooldown) return false;
    return true;
  }

  function placeTradeLocal(type, stake, duration){
    // PAPER: deterministic settlement by comparing entry/exit ticks
    const id = 'P' + Math.random().toString(36).slice(2,9).toUpperCase();
    const openTick = state.ticks.length;
    const expiryTick = openTick + duration;
    const rec = { id, type, stake, openTick, expiryTick, status:'OPEN', real:false, contract_id:null };
    state.open.set(id, rec);
    upsertOpenRow(rec);
    addLog(`[PAPER] OPEN ${id} ${type} stake ${fmt(stake)} duration ${duration}t`);
    state.lastOrderTs = Date.now();
    return rec;
  }

  function placeTradeReal(type, stake, duration){
    // build proposal request
    const symbol = $('#symbol').value;
    const proposal_req = {
      proposal: 1,
      amount: stake,
      basis: 'stake',
      contract_type: type,
      currency: 'USD',
      duration: duration,
      duration_unit: 't',
      symbol
    };
    send(proposal_req);
    addLog(`[REAL] Sent proposal: ${type} ${fmt(stake)} @ ${duration}t`);
    state.lastOrderTs = Date.now();
  }

  function placeTrade(type){
    const dur = Math.min(CONTRACT_DURATION_MAX, Math.max(1, Number($('#duration').value || 5)));
    const stake = Number($('#stake').value || 1);
    if (!canPlace()){ addLog('Blocked: cooldown or max open reached'); return; }
    if (dur > CONTRACT_DURATION_MAX){ addLog('Blocked: duration exceeds max'); return; }
    const mode = $('#mode').value;
    if (mode === 'paper'){
      placeTradeLocal(type, stake, dur);
    } else {
      if (!state.isAuthorized){ addLog('Not authorized — cannot place REAL trade'); return; }
      placeTradeReal(type, stake, dur);
    }
  }

  // ---------- PAPER settlement ----------
  function settlePaper(){
    const n = state.ticks.length;
    for (const [id, rec] of Array.from(state.open.entries())){
      if (rec.status !== 'OPEN' || rec.real) continue;
      if (n >= rec.expiryTick){
        const entryIdx = Math.max(0, rec.openTick - 1);
        const exitIdx = Math.max(0, rec.expiryTick - 1);
        const entry = state.ticks[entryIdx] ?? state.ticks[0];
        const exit = state.ticks[exitIdx] ?? state.ticks[state.ticks.length-1];
        let win = false;
        if (rec.type === 'CALL') win = exit > entry;
        if (rec.type === 'PUT') win = exit < entry;
        const payoutPct = Math.max(1, Number($('#payout').value || 90)) / 100;
        const pnl = win ? rec.stake * payoutPct : -rec.stake;
        rec.status = win ? 'WIN' : 'LOSS';
        state.virtualPL += pnl;
        state.trades++; if (win) state.wins++; else state.losses++;
        upsertOpenRow(rec);
        addLog(`[PAPER RESULT] ${rec.id} ${rec.type} => ${rec.status} (${win?'+':''}${fmt(pnl)})`);
        setTimeout(()=>{ removeOpenRow(rec.id); state.open.delete(rec.id); updateBadges(); }, 1200);
      }
    }
  }

  // ---------- WS message handling (REAL) ----------
  function handleWsMessage(msg){
    if (msg.error){ addLog('WS error: ' + (msg.error.message || JSON.stringify(msg.error))); return; }
    if (msg.msg_type === 'authorize'){
      state.isAuthorized = true;
      addLog('Authorized. Login ID: ' + (msg.authorize && msg.authorize.loginid ? msg.authorize.loginid : 'unknown'));
      $('#start').disabled = false;
    }
    if (msg.msg_type === 'tick'){
      const q = Number(msg.tick.quote);
      state.ticks.push(q); if (state.ticks.length > 2000) state.ticks.shift();
      settlePaper();
      return;
    }
    if (msg.msg_type === 'candles'){
      const cs = msg.candles.map(c => ({ open:Number(c.open), close:Number(c.close), high:Number(c.high), low:Number(c.low), epoch:c.epoch }));
      if (cs.length) state.candles.push(cs[cs.length-1]);
      if (state.candles.length > 500) state.candles.shift();
      return;
    }
    if (msg.msg_type === 'proposal'){
      const proposal = msg.proposal;
      if (!proposal) return;
      // Buy immediately using ask_price
      const id = proposal.id;
      const price = Number(proposal.ask_price);
      // buy request
      send({ buy: id, price });
      addLog('[REAL] Buying proposal id=' + id + ' price=' + fmt(price));
      return;
    }
    if (msg.msg_type === 'buy'){
      const b = msg.buy;
      const cid = b.contract_id;
      const longcode = b.longcode || '';
      const stake = Number(b.buy_price || $('#stake').value || 1);
      const localId = 'R' + cid;
      const openTick = state.ticks.length;
      const rec = { id: localId, type: (longcode.toUpperCase().includes('CALL') || longcode.toUpperCase().includes('RISE')) ? 'CALL' : 'PUT', stake, openTick, expiryTick:null, status:'OPEN', real:true, contract_id: cid };
      state.open.set(localId, rec);
      upsertOpenRow(rec);
      addLog('[REAL] Bought contract -> localId=' + localId + ' contract_id=' + cid);
      // subscribe to open-contract updates
      send({ proposal_open_contract: 1, contract_id: cid, subscribe: 1 });
      return;
    }
    if (msg.msg_type === 'proposal_open_contract'){
      const poc = msg.proposal_open_contract;
      if (!poc) return;
      const localId = 'R' + poc.contract_id;
      const o = state.open.get(localId);
      if (!o) return;
      // if settled/expired
      if (poc.is_settleable || poc.is_expired || poc.is_sold || poc.status === 'sold'){
        const profit = Number(poc.profit || 0);
        const win = profit >= 0;
        o.status = win ? 'WIN' : 'LOSS';
        o.expiryTick = state.ticks.length;
        // profit is net pnl (positive or negative)
        state.virtualPL += profit;
        state.trades++; if (win) state.wins++; else state.losses++;
        upsertOpenRow(o);
        addLog(`[REAL RESULT] ${localId} → ${o.status} profit ${fmt(profit)}`);
        setTimeout(()=>{ removeOpenRow(localId); state.open.delete(localId); updateBadges(); }, 1500);
      }
      return;
    }
  }

  // ---------- Connection ----------
  $('#connect').addEventListener('click', () => {
    if (state.ws && state.ws.readyState === 1){ addLog('Already connected'); return; }
    const appId = $('#appId').value.trim() || '1089';
    const url = `wss://ws.derivws.com/websockets/v3?app_id=${encodeURIComponent(appId)}`;
    state.ws = new WebSocket(url);
    setStatus('CONNECTING');
    addLog('Connecting: ' + url);
    state.ws.onopen = () => {
      setStatus('CONNECTED');
      addLog('Socket opened');
      const token = $('#token').value.trim();
      if (token) authorize(token);
      // subscribe ticks + candles for selected symbol
      const sym = $('#symbol').value;
      subscribeTicks(sym);
      subscribeCandles(sym, 60);
      $('#start').disabled = false;
    };
    state.ws.onmessage = (ev) => {
      try { const msg = JSON.parse(ev.data); handleWsMessage(msg); } catch(e){ addLog('msg parse err: '+ (e.message||e)); }
    };
    state.ws.onclose = () => { setStatus('DISCONNECTED'); addLog('Socket closed'); $('#start').disabled = true; };
    state.ws.onerror = () => { setStatus('ERROR'); addLog('Socket error'); };
  });

  // ---------- Bot evaluation loop ----------
  function botTick(){
    // ensure we have some ticks; if not, seed a simple tick for paper-mode
    if (state.ticks.length < 2){
      const base = state.ticks[0] || 1000;
      state.ticks.push(base + (Math.random() - 0.5) * 0.5);
    }
    // occasionally generate a pseudo-candle if no live candles exist
    if (state.candles.length < 20){
      const t = state.ticks;
      const open = t[t.length-3] || t[t.length-1];
      const close = t[t.length-1];
      const high = Math.max(open, close) + Math.random()*0.6;
      const low = Math.min(open, close) - Math.random()*0.6;
      state.candles.push({ open, close, high, low, epoch: Date.now() });
      if (state.candles.length > 500) state.candles.shift();
    }

    // Strategy combo: Trend2 then Precision
    let signal = signalTrend2();
    if (!signal) signal = signalPrecision();

    if (signal) placeTrade(signal);

    // settle any PAPER trades
    settlePaper();

    updateBadges();

    // risk controls
    const tp = Number($('#tp').value || 0);
    const sl = Number($('#sl').value || 0);
    if (tp && state.virtualPL >= tp){ stopBot(); addLog('Take Profit reached → stopped'); }
    if (sl && state.virtualPL <= sl){ stopBot(); addLog('Stop Loss reached → stopped'); }
  }

  function startBot(){
    if (state.running) return;
    const ms = Math.max(100, Number($('#tickms').value || 400));
    state.tickTimer = setInterval(botTick, ms);
    state.running = true;
    $('#start').disabled = true; $('#stop').disabled = false;
    addLog('Bot started (auto)');
  }
  function stopBot(){
    if (!state.running) return;
    clearInterval(state.tickTimer);
    state.tickTimer = null;
    state.running = false;
    $('#start').disabled = false; $('#stop').disabled = true;
    addLog('Bot stopped');
  }

  $('#start').addEventListener('click', () => {
    // if REAL mode and not authorized, disallow
    if ($('#mode').value === 'real' && !state.isAuthorized){ addLog('Please authorize (token) before starting REAL bot'); return; }
    startBot();
  });
  $('#stop').addEventListener('click', stopBot);

  // Expose manual placement helpers for console (optional)
  window.placeCall = () => placeTrade('CALL');
  window.placePut = () => placeTrade('PUT');

  // Init
  addLog('Ready. Connect (and authorize for REAL). Start bot after connecting.');
  updateBadges();

})();
</script>
</body>
</html>
